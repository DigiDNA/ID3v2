/*******************************************************************************
 * Copyright (c) 2014, Jean-David Gadina - www.xs-labs.com / www.digidna.net
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/
 
/* $Id$ */

/*!
 * @header      ID3v2-Frame.cpp
 * @copyright   (c) 2014 - Jean-David Gadina - www.xs-labs.com / www.digidna.net
 * @abstract    ID3v2 frame
 */

#include <ID3v2.h>
#include <ID3v2/ID3v2-PrivateTypes.h>
#include <sstream>

namespace ID3v2
{
    #ifdef __clang__
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wpadded"
    #endif
    
    class Frame::IMPL
    {
        public:
            
            static Frame * NewFrame( ID3v2Frame header, std::size_t size, char * data );
            
            IMPL( void );
            ~IMPL( void );
            
            ID3v2Frame  frame;
            std::size_t frameSize;
            char      * data;
    };
    
    #ifdef __clang__
    #pragma clang diagnostic pop
    #endif
    
    Frame * Frame::NewFrameFromFileHandle( FILE * fh )
    {
        Frame     * frame;
        ID3v2Frame  frameHeader;
        std::size_t frameSize;
        char      * data;
        
        if( fh == NULL )
        {
            return NULL;
        }
        
        memset( &frameHeader, 0, sizeof( ID3v2Frame ) );
        
        if( fread( &frameHeader, 1, sizeof( ID3v2Frame ), fh ) != sizeof( ID3v2Frame ) )
        {
            goto error;
        }
        
        {
            std::size_t s1;
            std::size_t s2;
            std::size_t s3;
            std::size_t s4;
            
            s1   = static_cast< std::size_t >( frameHeader.size[ 0 ] );
            s2   = static_cast< std::size_t >( frameHeader.size[ 1 ] );
            s3   = static_cast< std::size_t >( frameHeader.size[ 2 ] );
            s4   = static_cast< std::size_t >( frameHeader.size[ 3 ] );
            s1  &= 0xFF;
            s2  &= 0xFF;
            s3  &= 0xFF;
            s4  &= 0xFF;
            s1 <<= 24;
            s2 <<= 16;
            s3 <<= 8;
            
            frameSize = s1 | s2 | s3 | s4;
            data      = new char[ frameSize ];
            
            if( data == NULL )
            {
                goto error;
            }
            
            if( fread( data, 1, frameSize, fh ) != frameSize )
            {
                goto error;
            }
            
            return Frame::IMPL::NewFrame( frameHeader, frameSize, data );
        }
        
        return frame;
        
        error:
        
        return NULL;
    }
    
    Frame::Frame( void ): impl( new IMPL )
    {}
    
    Frame::~Frame( void )
    {
        if( this->impl != NULL )
        {
            delete this->impl;
        }
    }
    
    std::string Frame::GetName( void ) const
    {
        std::stringstream ss;
        
        ss << this->impl->frame.id[ 0 ];
        ss << this->impl->frame.id[ 1 ];
        ss << this->impl->frame.id[ 2 ];
        ss << this->impl->frame.id[ 3 ];
        
        return ss.str();
    }
    
    std::string Frame::GetDescription( void ) const
    {
        std::string name;
        
        name = this->GetName();
        
        if( name == "AENC" ) { return "Audio encryption"; }
        if( name == "APIC" ) { return "Attached picture"; }
        if( name == "COMM" ) { return "Comments"; }
        if( name == "COMR" ) { return "Commercial frame"; }
        if( name == "ENCR" ) { return "Encryption method registration"; }
        if( name == "EQUA" ) { return "Equalization"; }
        if( name == "ETCO" ) { return "Event timing codes"; }
        if( name == "GEOB" ) { return "General encapsulated object"; }
        if( name == "GRID" ) { return "Group identification registration"; }
        if( name == "IPLS" ) { return "Involved people list"; }
        if( name == "LINK" ) { return "Linked information"; }
        if( name == "MCDI" ) { return "Music CD identifier"; }
        if( name == "MLLT" ) { return "MPEG location lookup table"; }
        if( name == "OWNE" ) { return "Ownership frame"; }
        if( name == "PRIV" ) { return "Private frame"; }
        if( name == "PCNT" ) { return "Play counter"; }
        if( name == "POPM" ) { return "Popularimeter"; }
        if( name == "POSS" ) { return "Position synchronisation frame"; }
        if( name == "RBUF" ) { return "Recommended buffer size"; }
        if( name == "RVAD" ) { return "Relative volume adjustment"; }
        if( name == "RVRB" ) { return "Reverb"; }
        if( name == "SYLT" ) { return "Synchronized lyric/text"; }
        if( name == "SYTC" ) { return "Synchronized tempo codes"; }
        if( name == "TALB" ) { return "Album/Movie/Show title"; }
        if( name == "TBPM" ) { return "BPM (beats per minute)"; }
        if( name == "TCOM" ) { return "Composer"; }
        if( name == "TCON" ) { return "Content type"; }
        if( name == "TCOP" ) { return "Copyright message"; }
        if( name == "TDAT" ) { return "Date"; }
        if( name == "TDLY" ) { return "Playlist delay"; }
        if( name == "TENC" ) { return "Encoded by"; }
        if( name == "TEXT" ) { return "Lyricist/Text writer"; }
        if( name == "TFLT" ) { return "File type"; }
        if( name == "TIME" ) { return "Time"; }
        if( name == "TIT1" ) { return "Content group description"; }
        if( name == "TIT2" ) { return "Title/songname/content description"; }
        if( name == "TIT3" ) { return "Subtitle/Description refinement"; }
        if( name == "TKEY" ) { return "Initial key"; }
        if( name == "TLAN" ) { return "Language(s)"; }
        if( name == "TLEN" ) { return "Length"; }
        if( name == "TMED" ) { return "Media type"; }
        if( name == "TOAL" ) { return "Original album/movie/show title"; }
        if( name == "TOFN" ) { return "Original filename"; }
        if( name == "TOLY" ) { return "Original lyricist(s)/text writer(s)"; }
        if( name == "TOPE" ) { return "Original artist(s)/performer(s)"; }
        if( name == "TORY" ) { return "Original release year"; }
        if( name == "TOWN" ) { return "File owner/licensee"; }
        if( name == "TPE1" ) { return "Lead performer(s)/Soloist(s)"; }
        if( name == "TPE2" ) { return "Band/orchestra/accompaniment"; }
        if( name == "TPE3" ) { return "Conductor/performer refinement"; }
        if( name == "TPE4" ) { return "Interpreted, remixed, or otherwise modified by"; }
        if( name == "TPOS" ) { return "Part of a set"; }
        if( name == "TPUB" ) { return "Publisher"; }
        if( name == "TRCK" ) { return "Track number/Position in set"; }
        if( name == "TRDA" ) { return "Recording dates"; }
        if( name == "TRSN" ) { return "Internet radio station name"; }
        if( name == "TRSO" ) { return "Internet radio station owner"; }
        if( name == "TSIZ" ) { return "Size"; }
        if( name == "TSRC" ) { return "ISRC (international standard recording code)"; }
        if( name == "TSSE" ) { return "Software/Hardware and settings used for encoding"; }
        if( name == "TYER" ) { return "Year"; }
        if( name == "TXXX" ) { return "User defined text information frame"; }
        if( name == "UFID" ) { return "Unique file identifier"; }
        if( name == "USER" ) { return "Terms of use"; }
        if( name == "USLT" ) { return "Unsychronized lyric/text transcription"; }
        if( name == "WCOM" ) { return "Commercial information"; }
        if( name == "WCOP" ) { return "Copyright/Legal information"; }
        if( name == "WOAF" ) { return "Official audio file webpage"; }
        if( name == "WOAR" ) { return "Official artist/performer webpage"; }
        if( name == "WOAS" ) { return "Official audio source webpage"; }
        if( name == "WORS" ) { return "Official internet radio station homepage"; }
        if( name == "WPAY" ) { return "Payment"; }
        if( name == "WPUB" ) { return "Publishers official webpage"; }
        if( name == "WXXX" ) { return "User defined URL link frame"; }
        
        return "Unknown";
    }
    
    std::size_t Frame::GetSize( void ) const
    {
        return this->impl->frameSize;
    }
    
    const char * Frame::GetData( void ) const
    {
        return this->impl->data;
    }
    
    unsigned short  Frame::GetFlags( void ) const
    {
        unsigned short f1;
        unsigned short f2;
        
        f1   = static_cast< unsigned short >( this->impl->frame.flags[ 0 ] );
        f2   = static_cast< unsigned short >( this->impl->frame.flags[ 1 ] );
        f1  &= 0xFF;
        f2  &= 0xFF;
        f1 <<= 8;
        
        return f1 | f2;
    }
    
    bool Frame::HasFlag( Flag flag ) const
    {
        unsigned short flags;
        
        flags = this->GetFlags();
        
        switch( flag )
        {
            case FlagTagAlterPreservation:  return ( flags & 0x8000 ) ? true : false;
            case FlagFileAlterPreservation: return ( flags & 0x4000 ) ? true : false;
            case FlagReadOnly:              return ( flags & 0x2000 ) ? true : false;
            case FlagCompression:           return ( flags & 0x0080 ) ? true : false;
            case FlagEncryption:            return ( flags & 0x0040 ) ? true : false;
            case FlagGroupingIdentity:      return ( flags & 0x0020 ) ? true : false;
        }

        return false;
    }
    
    Frame * Frame::IMPL::NewFrame( ID3v2Frame header, std::size_t size, char * data )
    {
        Frame           * frame;
        std::stringstream ss;
        std::string       name;
        
        ss << header.id[ 0 ];
        ss << header.id[ 1 ];
        ss << header.id[ 2 ];
        ss << header.id[ 3 ];
        
        name = ss.str();
        
             if( name == "AENC" ) { frame = new Frames::AENC(); }
        else if( name == "APIC" ) { frame = new Frames::APIC(); }
        else if( name == "COMM" ) { frame = new Frames::COMM(); }
        else if( name == "COMR" ) { frame = new Frames::COMR(); }
        else if( name == "ENCR" ) { frame = new Frames::ENCR(); }
        else if( name == "EQUA" ) { frame = new Frames::EQUA(); }
        else if( name == "ETCO" ) { frame = new Frames::ETCO(); }
        else if( name == "GEOB" ) { frame = new Frames::GEOB(); }
        else if( name == "GRID" ) { frame = new Frames::GRID(); }
        else if( name == "IPLS" ) { frame = new Frames::IPLS(); }
        else if( name == "LINK" ) { frame = new Frames::LINK(); }
        else if( name == "MCDI" ) { frame = new Frames::MCDI(); }
        else if( name == "MLLT" ) { frame = new Frames::MLLT(); }
        else if( name == "OWNE" ) { frame = new Frames::OWNE(); }
        else if( name == "PCNT" ) { frame = new Frames::PCNT(); }
        else if( name == "POPM" ) { frame = new Frames::POPM(); }
        else if( name == "POSS" ) { frame = new Frames::POSS(); }
        else if( name == "PRIV" ) { frame = new Frames::PRIV(); }
        else if( name == "RBUF" ) { frame = new Frames::RBUF(); }
        else if( name == "RVAD" ) { frame = new Frames::RVAD(); }
        else if( name == "RVRB" ) { frame = new Frames::RVRB(); }
        else if( name == "SYLT" ) { frame = new Frames::SYLT(); }
        else if( name == "SYTC" ) { frame = new Frames::SYTC(); }
        else if( name == "TALB" ) { frame = new Frames::TALB(); }
        else if( name == "TBPM" ) { frame = new Frames::TBPM(); }
        else if( name == "TCOM" ) { frame = new Frames::TCOM(); }
        else if( name == "TCON" ) { frame = new Frames::TCON(); }
        else if( name == "TCOP" ) { frame = new Frames::TCOP(); }
        else if( name == "TDAT" ) { frame = new Frames::TDAT(); }
        else if( name == "TDLY" ) { frame = new Frames::TDLY(); }
        else if( name == "TENC" ) { frame = new Frames::TENC(); }
        else if( name == "TEXT" ) { frame = new Frames::TEXT(); }
        else if( name == "TFLT" ) { frame = new Frames::TFLT(); }
        else if( name == "TIME" ) { frame = new Frames::TIME(); }
        else if( name == "TIT1" ) { frame = new Frames::TIT1(); }
        else if( name == "TIT2" ) { frame = new Frames::TIT2(); }
        else if( name == "TIT3" ) { frame = new Frames::TIT3(); }
        else if( name == "TKEY" ) { frame = new Frames::TKEY(); }
        else if( name == "TLAN" ) { frame = new Frames::TLAN(); }
        else if( name == "TLEN" ) { frame = new Frames::TLEN(); }
        else if( name == "TMED" ) { frame = new Frames::TMED(); }
        else if( name == "TOAL" ) { frame = new Frames::TOAL(); }
        else if( name == "TOFN" ) { frame = new Frames::TOFN(); }
        else if( name == "TOLY" ) { frame = new Frames::TOLY(); }
        else if( name == "TOPE" ) { frame = new Frames::TOPE(); }
        else if( name == "TORY" ) { frame = new Frames::TORY(); }
        else if( name == "TOWN" ) { frame = new Frames::TOWN(); }
        else if( name == "TPE1" ) { frame = new Frames::TPE1(); }
        else if( name == "TPE2" ) { frame = new Frames::TPE2(); }
        else if( name == "TPE3" ) { frame = new Frames::TPE3(); }
        else if( name == "TPE4" ) { frame = new Frames::TPE4(); }
        else if( name == "TPOS" ) { frame = new Frames::TPOS(); }
        else if( name == "TPUB" ) { frame = new Frames::TPUB(); }
        else if( name == "TRCK" ) { frame = new Frames::TRCK(); }
        else if( name == "TRDA" ) { frame = new Frames::TRDA(); }
        else if( name == "TRSN" ) { frame = new Frames::TRSN(); }
        else if( name == "TRSO" ) { frame = new Frames::TRSO(); }
        else if( name == "TSIZ" ) { frame = new Frames::TSIZ(); }
        else if( name == "TSRC" ) { frame = new Frames::TSRC(); }
        else if( name == "TSSE" ) { frame = new Frames::TSSE(); }
        else if( name == "TXXX" ) { frame = new Frames::TXXX(); }
        else if( name == "TYER" ) { frame = new Frames::TYER(); }
        else if( name == "UFID" ) { frame = new Frames::UFID(); }
        else if( name == "USER" ) { frame = new Frames::USER(); }
        else if( name == "USLT" ) { frame = new Frames::USLT(); }
        else if( name == "WCOM" ) { frame = new Frames::WCOM(); }
        else if( name == "WCOP" ) { frame = new Frames::WCOP(); }
        else if( name == "WOAF" ) { frame = new Frames::WOAF(); }
        else if( name == "WOAR" ) { frame = new Frames::WOAR(); }
        else if( name == "WOAS" ) { frame = new Frames::WOAS(); }
        else if( name == "WORS" ) { frame = new Frames::WORS(); }
        else if( name == "WPAY" ) { frame = new Frames::WPAY(); }
        else if( name == "WPUB" ) { frame = new Frames::WPUB(); }
        else if( name == "WXXX" ) { frame = new Frames::WXXX(); }
        else
        {
            frame = new Frames::Unknown();
        }
        
        frame->impl->frame      = header;
        frame->impl->frameSize  = size;
        frame->impl->data       = data;
        
        frame->ProcessData();
        
        return frame;
    }
    
    Frame::IMPL::IMPL( void )
    {
        this->frameSize = 0;
        this->data      = NULL;
        
        memset( &( this->frame ), 0, sizeof( ID3v2Frame ) );
    }
    
    Frame::IMPL::~IMPL( void )
    {
        delete[] this->data;
    }
}
